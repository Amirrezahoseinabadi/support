import { Router } from 'itty-router';

// یک روتر جدید برای مدیریت مسیرهای مختلف ایجاد می‌کنیم
const router = Router();

// << آدرس دیتابیس Firebase شما در اینجا قرار داده شد >>
const FIREBASE_URL = 'https://support-app-final-default-rtdb.asia-southeast1.firebasedatabase.app';

// Middleware برای اضافه کردن هدرهای CORS به تمام پاسخ‌ها
const withCors = (response) => {
    response.headers.set('Access-Control-Allow-Origin', '*');
    response.headers.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
    response.headers.set('Access-Control-Allow-Headers', 'Content-Type');
    return response;
};

// تابع برای مدیریت درخواست‌های CORS pre-flight
const handleOptions = request => {
    return withCors(new Response(null));
};

/**
 * مسیر برای ایجاد یک تیکت جدید
 * POST /tickets
 */
router.post('/tickets', async (request) => {
    try {
        const body = await request.json();
        const { telegram_id, subject, department, message } = body;

        if (!telegram_id || !subject || !department || !message) {
            return new Response(JSON.stringify({ success: false, error: 'تمام فیلدها الزامی هستند' }), { status: 400 });
        }

        // 1. ایجاد تیکت جدید در کالکشن tickets
        const ticketPayload = {
            telegram_id,
            subject,
            department,
            status: 'open',
            created_at: new Date().toISOString(),
        };

        const ticketRes = await fetch(`${FIREBASE_URL}/tickets.json`, {
            method: 'POST',
            body: JSON.stringify(ticketPayload),
        });

        if (!ticketRes.ok) {
            const errorText = await ticketRes.text();
            throw new Error(`خطا در ایجاد تیکت در Firebase: ${errorText}`);
        }
        const ticketData = await ticketRes.json();
        const newTicketId = ticketData.name; // Firebase یک شناسه یکتا به نام 'name' برمی‌گرداند

        // 2. افزودن اولین پیام به تیکت در کالکشن messages
        const messagePayload = {
            sender: 'user',
            text: message,
            created_at: new Date().toISOString(),
        };

        const messageRes = await fetch(`${FIREBASE_URL}/messages/${newTicketId}.json`, {
            method: 'POST',
            body: JSON.stringify(messagePayload),
        });

        if (!messageRes.ok) {
            const errorText = await messageRes.text();
            throw new Error(`خطا در ثبت اولین پیام در Firebase: ${errorText}`);
        }

        return new Response(JSON.stringify({ success: true, data: { id: newTicketId, ...ticketPayload } }), { status: 201 });
    } catch (error) {
        console.error('Error creating ticket:', error.message);
        return new Response(JSON.stringify({ success: false, error: error.message }), { status: 500 });
    }
});

/**
 * مسیر برای ارسال یک پیام جدید در یک تیکت
 * POST /messages
 */
router.post('/messages', async (request) => {
    try {
        const body = await request.json();
        const { ticket_id, sender, text } = body;

        if (!ticket_id || !sender || !text) {
            return new Response(JSON.stringify({ success: false, error: 'تمام فیلدها الزامی هستند' }), { status: 400 });
        }

        // 1. افزودن پیام جدید
        const messagePayload = {
            sender,
            text,
            created_at: new Date().toISOString(),
        };
        const messageRes = await fetch(`${FIREBASE_URL}/messages/${ticket_id}.json`, {
            method: 'POST',
            body: JSON.stringify(messagePayload),
        });

        if (!messageRes.ok) {
            const errorText = await messageRes.text();
            throw new Error(`خطا در ارسال پیام به Firebase: ${errorText}`);
        }
        const responseData = await messageRes.json();

        // 2. آپدیت وضعیت تیکت به 'open' چون کاربر پاسخ داده
        if (sender === 'user') {
            await fetch(`${FIREBASE_URL}/tickets/${ticket_id}.json`, {
                method: 'PATCH', // از PATCH برای آپدیت فیلدهای مشخص استفاده می‌شود
                body: JSON.stringify({ status: 'open' }),
            });
        }

        return new Response(JSON.stringify({ success: true, data: responseData }), { status: 201 });
    } catch (error) {
        console.error('Error sending message:', error.message);
        return new Response(JSON.stringify({ success: false, error: error.message }), { status: 500 });
    }
});

// مدیریت درخواست‌های OPTIONS برای CORS
router.options('*', handleOptions);

// مدیریت مسیرهای ناموجود
router.all('*', () => new Response(JSON.stringify({ success: false, error: 'مسیر یافت نشد' }), { status: 404 }));

export default {
    async fetch(request, env, ctx) {
        const response = await router.handle(request, env, ctx);
        return withCors(response);
    },
};
